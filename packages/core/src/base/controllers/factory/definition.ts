import { getIdType, idParamsSchema, jsonContent, jsonResponse } from '@/base/models';
import { CountSchema, FilterSchema, WhereSchema } from '@/base/repositories';
import { RouteConfig, z } from '@hono/zod-openapi';
import { HTTP } from '@venizia/ignis-helpers';
import { TAuthStrategy } from '@/components/auth/authenticate/common';
import { RestPaths, TAuthRouteConfig } from '../common';

/**
 * Type-safe wrapper for defining route configurations.
 *
 * Ensures the configuration object maintains proper typing and
 * is compatible with the controller's route binding methods.
 *
 * @typeParam RC - The route configuration type
 * @param configs - The route configuration object
 * @returns The same configuration with proper typing
 *
 * @example
 * ```typescript
 * const GET_USER = defineRouteConfigs({
 *   method: 'get',
 *   path: '/{id}',
 *   authStrategies: ['jwt'],
 *   request: { params: z.object({ id: z.string() }) },
 *   responses: { 200: jsonResponse({ schema: UserSchema }) }
 * });
 * ```
 */
export const defineRouteConfigs = <RC extends TAuthRouteConfig<RouteConfig>>(configs: RC) => {
  return configs;
};

/**
 * Per-route authentication configuration
 *
 * Priority (endpoint config takes precedence over controller):
 * 1. If endpoint has `skipAuth: true` → no auth (ignores controller authStrategies)
 * 2. If endpoint has `authStrategies` → use these (overrides controller authStrategies)
 * 3. Otherwise → use controller-level authStrategies
 *
 * @example
 * // Skip auth for this endpoint (even if controller has authStrategies)
 * { skipAuth: true }
 *
 * @example
 * // Use specific auth for this endpoint (overrides controller)
 * { authStrategies: ['jwt'] }
 */
type TRouteAuthConfig =
  | { skipAuth: true }
  | { skipAuth?: false; authStrategies: Array<TAuthStrategy> };

/** Configuration for read-only routes (count, find, findOne, findById) */
export type TReadRouteConfig = TRouteAuthConfig & {
  /** Custom response schema (overrides entity's select schema) */
  schema?: z.ZodObject;
};

/** Configuration for write routes (create, updateById, updateBy) */
export type TWriteRouteConfig = TReadRouteConfig & {
  /** Custom request body schema (overrides entity's create/update schema) */
  requestBody?: z.ZodObject;
};

/** Configuration for delete routes (deleteById, deleteBy) */
export type TDeleteRouteConfig = TRouteAuthConfig & {
  /** Custom response schema */
  schema?: z.ZodObject;
};

/**
 * Per-route configuration for CRUD controller endpoints.
 *
 * Allows customizing authentication and schemas for individual routes
 * generated by {@link ControllerFactory.defineCrudController}.
 *
 * @example
 * ```typescript
 * const routes: TRoutesConfig = {
 *   // Public read endpoints
 *   find: { skipAuth: true },
 *   findById: { skipAuth: true },
 *
 *   // Protected write endpoints with custom schemas
 *   create: {
 *     authStrategies: ['jwt'],
 *     requestBody: CreateUserSchema,
 *     schema: UserResponseSchema
 *   },
 *   updateById: { authStrategies: ['jwt'] },
 *   deleteById: { authStrategies: ['jwt', 'admin'] }
 * };
 * ```
 */
export type TRoutesConfig = {
  // READ routes
  count?: TReadRouteConfig;
  find?: TReadRouteConfig;
  findOne?: TReadRouteConfig;
  findById?: TReadRouteConfig;

  // WRITE routes
  create?: TWriteRouteConfig;
  updateById?: TWriteRouteConfig;
  updateBy?: TWriteRouteConfig;

  // DELETE routes
  deleteById?: TDeleteRouteConfig;
  deleteBy?: TDeleteRouteConfig;
};

/**
 * Generates complete route configurations for a CRUD controller.
 *
 * Creates standardized route configs for all CRUD operations (count, find,
 * findById, findOne, create, updateById, updateBy, deleteById, deleteBy)
 * with proper authentication and schema validation.
 *
 * Used internally by {@link ControllerFactory.defineCrudController}.
 *
 * @param opts - Configuration options
 * @param opts.isStrict - Whether request schemas are required
 * @param opts.idType - The ID field type ('string' | 'number')
 * @param opts.authStrategies - Default auth strategies for all routes
 * @param opts.schema - Entity schemas for select, create, and update operations
 * @param opts.routes - Per-route configuration overrides
 * @returns Object containing all route configurations (COUNT, FIND, etc.)
 */
export const defineControllerRouteConfigs = (opts: {
  isStrict: boolean;
  idType: ReturnType<typeof getIdType>;
  authStrategies?: Array<TAuthStrategy>;
  schema: { select: z.ZodObject; create: z.ZodObject; update: z.ZodObject };
  routes?: TRoutesConfig;
}) => {
  const {
    isStrict,
    idType,
    authStrategies = [],
    schema: { select: selectSchema, create: createSchema, update: updateSchema },
    routes = {},
  } = opts;

  /**
   * Resolves auth strategies for a specific route
   *
   * Priority (endpoint first, then controller fallback):
   * 1. Endpoint skipAuth=true → no auth (ignores controller)
   * 2. Endpoint authStrategies → override controller (empty = no auth)
   * 3. Controller authStrategies → default fallback
   */
  const resolveRouteAuth = (routeKey: keyof TRoutesConfig): Array<TAuthStrategy> => {
    const endpointConfig = routes[routeKey];

    // Endpoint skip → no auth
    if (endpointConfig?.skipAuth) {
      return [];
    }

    // Endpoint authStrategies → override controller (empty = no auth)
    if (endpointConfig?.authStrategies) {
      return endpointConfig.authStrategies;
    }

    // Fallback to controller authStrategies
    return authStrategies;
  };

  const optionalTrackableHeaders = z.object({
    [HTTP.Headers.REQUEST_TRACING_ID]: z.string().optional().openapi({
      description: 'Optional request ID',
    }),
    [HTTP.Headers.REQUEST_CHANNEL]: z
      .string()
      .optional()
      .openapi({
        description: 'Optional request channel',
        examples: ['channel-1', 'web', 'spos'],
      }),
    [HTTP.Headers.REQUEST_DEVICE_INFO]: z
      .string()
      .optional()
      .openapi({
        description: 'Optional request device info',
        examples: ['dev-1', 'device-abc', 'd-unique-id'],
      }),
  });

  const countableHeaders = z.object({
    [HTTP.Headers.REQUEST_COUNT_DATA]: z
      .string()
      .optional()
      .openapi({
        description:
          'Controls response format. When "true" (default): returns {count, data}. When "false": returns data only.',
        examples: ['true', '1', 'false', '0'],
      }),
  });

  /** Common response headers for all routes (OpenAPI Header Object format) */
  const commonResponseHeaders = {
    [HTTP.Headers.REQUEST_TRACING_ID]: {
      description: 'Echo of the request tracing ID',
      schema: { type: 'string' as const },
    },
    [HTTP.Headers.RESPONSE_COUNT_DATA]: {
      description: 'Number of records in response',
      schema: { type: 'string' as const, examples: ['1', '10', '100'] },
    },
    [HTTP.Headers.RESPONSE_FORMAT]: {
      description: 'Response format indicator',
      schema: { type: 'string' as const, examples: ['array', 'object'] },
    },
  };

  /** Response headers for FIND routes (includes Content-Range) */
  const findResponseHeaders = {
    ...commonResponseHeaders,
    [HTTP.Headers.CONTENT_RANGE]: {
      description: 'Content range for pagination (e.g., "records 0-24/100")',
      schema: { type: 'string' as const, examples: ['records 0-24/100', 'records 25-49/100'] },
    },
  };

  /**
   * Creates a union schema for conditional count response.
   *
   * Response format depends on `x-request-count` header:
   * - `true` (default): `{ count: number, data: T }`
   * - `false`: `T` (data only)
   */
  const conditionalCountResponse = <T extends z.ZodTypeAny>(dataSchema: T) => {
    return z.union([
      z.object({ count: CountSchema, data: dataSchema }).openapi({
        description: 'Response with count (when x-request-count header is "true" or omitted)',
      }),
      dataSchema.openapi({
        description: 'Data only response (when x-request-count header is "false")',
      }),
    ]);
  };

  const rs = {
    // -----------------------------------------------------------------------------
    // Count
    // -----------------------------------------------------------------------------
    COUNT: defineRouteConfigs({
      method: HTTP.Methods.GET,
      path: RestPaths.COUNT,
      authStrategies: resolveRouteAuth('count'),
      request: {
        query: z.object({ where: isStrict ? WhereSchema : z.optional(WhereSchema) }),
        headers: optionalTrackableHeaders,
      },
      responses: jsonResponse({
        schema: routes.count?.schema ?? CountSchema,
        headers: commonResponseHeaders,
      }),
    }),

    // -----------------------------------------------------------------------------
    // Find
    // -----------------------------------------------------------------------------
    FIND: defineRouteConfigs({
      method: HTTP.Methods.GET,
      path: RestPaths.ROOT,
      authStrategies: resolveRouteAuth('find'),
      request: {
        query: z.object({ filter: FilterSchema }),
        headers: optionalTrackableHeaders.extend(countableHeaders.shape),
      },
      responses: jsonResponse({
        schema: routes.find?.schema ?? conditionalCountResponse(z.array(selectSchema)),
        headers: findResponseHeaders,
      }),
    }),

    // -----------------------------------------------------------------------------
    // Find by ID
    // -----------------------------------------------------------------------------
    FIND_BY_ID: defineRouteConfigs({
      method: HTTP.Methods.GET,
      path: '/{id}',
      authStrategies: resolveRouteAuth('findById'),
      request: {
        params: idParamsSchema({ idType }),
        query: z.object({ filter: FilterSchema }),
        headers: optionalTrackableHeaders.extend(countableHeaders.shape),
      },
      responses: jsonResponse({
        schema: routes.findById?.schema ?? conditionalCountResponse(selectSchema),
        headers: commonResponseHeaders,
      }),
    }),

    // -----------------------------------------------------------------------------
    // Find One
    // -----------------------------------------------------------------------------
    FIND_ONE: defineRouteConfigs({
      method: HTTP.Methods.GET,
      path: RestPaths.FIND_ONE,
      authStrategies: resolveRouteAuth('findOne'),
      request: {
        query: z.object({ filter: FilterSchema }),
        headers: optionalTrackableHeaders.extend(countableHeaders.shape),
      },
      responses: jsonResponse({
        schema: routes.findOne?.schema ?? conditionalCountResponse(selectSchema),
        headers: commonResponseHeaders,
      }),
    }),

    // -----------------------------------------------------------------------------
    // Create
    // -----------------------------------------------------------------------------
    CREATE: defineRouteConfigs({
      method: HTTP.Methods.POST,
      path: RestPaths.ROOT,
      authStrategies: resolveRouteAuth('create'),
      request: {
        body: jsonContent({
          description: 'CREATE | Request body',
          schema: routes.create?.requestBody ?? createSchema,
        }),
        headers: optionalTrackableHeaders.extend(countableHeaders.shape),
      },
      responses: jsonResponse({
        schema: routes.create?.schema ?? conditionalCountResponse(selectSchema),
        headers: commonResponseHeaders,
      }),
    }),

    // -----------------------------------------------------------------------------
    // Update by ID
    // -----------------------------------------------------------------------------
    UPDATE_BY_ID: defineRouteConfigs({
      method: HTTP.Methods.PATCH,
      path: '/{id}',
      authStrategies: resolveRouteAuth('updateById'),
      request: {
        params: idParamsSchema({ idType }),
        body: jsonContent({
          description: 'UPDATE BY ID | Request body',
          schema: routes.updateById?.requestBody ?? updateSchema,
        }),
        headers: optionalTrackableHeaders.extend(countableHeaders.shape),
      },
      responses: jsonResponse({
        schema: routes.updateById?.schema ?? conditionalCountResponse(selectSchema),
        headers: commonResponseHeaders,
      }),
    }),

    // -----------------------------------------------------------------------------
    // Update by
    // -----------------------------------------------------------------------------
    UPDATE_BY: defineRouteConfigs({
      method: HTTP.Methods.PATCH,
      path: RestPaths.ROOT,
      authStrategies: resolveRouteAuth('updateBy'),
      request: {
        query: z.object({ where: WhereSchema }),
        body: jsonContent({
          description: 'UPDATE BY CONDITION | Request body',
          schema: routes.updateBy?.requestBody ?? updateSchema,
        }),
        headers: optionalTrackableHeaders.extend(countableHeaders.shape),
      },
      responses: jsonResponse({
        schema: routes.updateBy?.schema ?? conditionalCountResponse(z.array(selectSchema)),
        headers: commonResponseHeaders,
      }),
    }),

    // -----------------------------------------------------------------------------
    // Delete by ID
    // -----------------------------------------------------------------------------
    DELETE_BY_ID: defineRouteConfigs({
      method: HTTP.Methods.DELETE,
      path: '/{id}',
      authStrategies: resolveRouteAuth('deleteById'),
      request: {
        params: idParamsSchema({ idType }),
        headers: optionalTrackableHeaders.extend(countableHeaders.shape),
      },
      responses: jsonResponse({
        schema: routes.deleteById?.schema ?? conditionalCountResponse(selectSchema),
        headers: commonResponseHeaders,
      }),
    }),

    // -----------------------------------------------------------------------------
    // Delete by
    // -----------------------------------------------------------------------------
    DELETE_BY: defineRouteConfigs({
      method: HTTP.Methods.DELETE,
      path: RestPaths.ROOT,
      authStrategies: resolveRouteAuth('deleteBy'),
      request: {
        query: z.object({ where: WhereSchema }),
        headers: optionalTrackableHeaders.extend(countableHeaders.shape),
      },
      responses: jsonResponse({
        schema: routes.deleteBy?.schema ?? conditionalCountResponse(z.array(selectSchema)),
        headers: commonResponseHeaders,
      }),
    }),
  } as const;

  return rs;
};
